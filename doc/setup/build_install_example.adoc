ifndef::include-only-once[]
:root-path: ../
include::{root-path}_config.adoc[]
endif::[]

= Static / dynamic linking for co-simulation

== Windows

**Dynamic Linking**

Since, on windows symbols are not exported per default it can be kind of annoying to deal with this during 
protobuf header generation (see for example  https://groups.google.com/g/protobuf/c/PDR1bqRazts).
So basically thats one reason to use static linking.

**Static Linking**

Static linking might require to manually build protobuf. 
Its important to notice that on windows you can also specify how to link against the C runtime (not sure how this works on linux).  
Basically this can be set in CMake e.g. https://cmake.org/cmake/help/latest/prop_tgt/MSVC_RUNTIME_LIBRARY.html

So when statically linking it makes sense to still dynamically link against the C Runtime.
(This is important e.g. when building shared libraries, since a static C runtime will create an isolated heap for your  dll,
which can lead to segfaults depending on what you expose on your public interfaces)

The easiest way to achieve this on Windows without setting all the stuff manually in Cmake and building protobuf 
is to actually use vcpkg:

**Install static protobuf:**

----
vcpkg install --triplet=x64-windows-static-md protobuf
----

This vcpkg triplet enables static linking with dynamic c-runtime.

**Build:**

For cmake configuration we can directly specify our vcpkg installation:
----
cmake .. -DVCPKG_TARGET_TRIPLET=x64-windows-static-md -DCMAKE_TOOLCHAIN_FILE=C:/path/to/vcpkg/scripts/buildsystems/vcpkg.cmake -A x64
cmake --build . --config Release
----

== Linux

There is already a good answer from pmai so here some additional points to this.

**Dynamic linking**

As already mentioned by pmai shared linking is an option on linux.
`LINK_WITH_SHARED_OSI` has to be enabled.

**Static linking**

A common error here is to just install protobuf with apt and link against it. 
This means that your OSI is build statically but still linking dynamically against protobuf.
Here, again either protobuf has to build statically from source or some solution e.g. vcpkg needs to be utilized.

= Building and installing examples

OSMP includes three examples located in `_osmp_/examples`:

`OSMPDummySensor/`::
Can be used as a simple dummy sensor model, demonstrating the use of OSI for sensor models consuming sensor view data and generating sensor data output.

`OSMPDummySource/`::
Can be used as a simple source of sensor view data and ground-truth data.
It can be connected to the input of an `OSMPDummySensor` model, for simple testing and demonstration purposes.

`OSMPCNetworkProxy/`::
Demonstrates a simple C network proxy that can send and receive OSI data via TCP sockets.

**Prerequisites**

* You have installed _cmake_ version 3.10.2 or higher.
* You have installed _protobuf_ version 3.0.0 or higher according to the way of linking of your choice, as described above.

**Steps**

. Clone the OSMP repository.
+
----
git clone https://github.com/OpenSimulationInterface/osi-sensor-model-packaging.git
----
+
. Switch to the OSMP repository.
+
----
cd osi-sensor-model-packaging
----
+
. Update and initialize the OSI submodule.
+
----
git submodule update --init
----
+
. Switch to the `examples/` directory.
+
----
cd examples
----
+
. Create a new directory called `build/`.
+
----
mkdir -p build
----
+
. Switch to the `build/` directory.
+
----
cd build
----
+
. Run _cmake_ in the parent directory.
+
----
cmake ..
----
+
. Run _cmake_ build.
+
----
cmake --build .
----
